           LinkedList
видалення елементів за константний час

           HashMap

Найбільш використовується імплементація інтерфейсу Map - це HashMap.
HashMap в Java - це реалізація структури даних "хеш-таблиця" з Java Collections Framework.

Працює по принципу хешировання
Колекція, що вміщує в основу масив, елементами масива є структура LinkedList, і дані, що добавляються в HashMap добавляються до структури LinkedList.
Часто називають, що елементи масива table вміщують в собі спочатку (buckets) смітники, а уже в них вміщуються елементи HashMap


- не є синхронізованою

Яка скорость вставки або пошука елемента в HashMap?
O(1) – константна дуже висока швидкість, в кращому випадку в не кращому O(n);
O(1) – використовується, коди дуже добре реалізовано hashcode
O(1) та O(n) – залежать від реалізації hashcode

Для кращої продуктивності buckets залежить чи гарно буде написаний hashcode
O(n) – час проходження по LinkedList

- capacity 16
- Значення об'єкта HashMap перебираються за допомогою ітератора

*Порядок зберігання даних: Випадковий. Немає гарантій, що порядок збережеться протягом часу
*час доступу до елементів: O(1)
*Імплементовані інтерфейси: Map
*Імплементація на основі структури даних: кошики Buckets
*Можливість роботи з null-ключем: Можна
*Потокобезпечна:ні


            HashTable

- застарілий варіант HashMap, така сама структура

- є синхронізованим, тому його методи не такі швидкі
- не ключ ні значення не може бути null

- не порядкове збереження даних
- якщо потрібно використовувати map для багатопоточності, краще використовувати ConcurrentHashMap

- використовує метод equals для перевірки на рівність
- початкова ємність 11
- Hashtable - це єдиний клас, крім вектора, який використовує перечислювач (enumerator) для перебору значень об'єкта Hashtable

             LinkedHashMap

- наслідується від Map
- продуктивність методі трохи менша, ніж в самих методах HashMap
- оскільки є ключове слово Linked в нас будуть зберігатись ще силки на попередні та на ступні елементи

new LinkedHashMap(1,2,3)
1 - capacity
2 - loadFactory
3 - accessOrder  виходить, що при виконанні любих методів, то порядок зміниться

*Порядок зберігання даних: в порядку добавленні в колекцію або в порядку їх виконання
*час доступу до елементів: O(1)
*Імплементовані інтерфейси: Map
*Імплементація на основі структури даних: кошики Buckets
*Можливість роботи з null-ключем: Можна
*Потокобезпечна:ні

              TreeMap

- Іноді необхідно зберігати дані у структурованому вигляді з можливістю навігації за ними. У такому разі на допомогу приходить інша реалізація інтерфейсу Map - TreeMap .
- Колекція представляється елементами пари ключ/значення.
- В TreeMap зберігаються в фільтрації (по ключам) по зростаючому порядку.
- Унікальність ключів зберігаються, а значень ні, як в HashMap

- Щоб вставляти об‘єкти в ключі потрібно, щоб ці об’єкти імплементували Comparable
- В TreeMap можна не перевизначати методи equals та hashcode, тому тут використовується в операціях (add, get) метод comparable, але для метода containsvalue використовується equals.
- В кращих тонах потрібно завжди перевизначати метод equals та hashcode.
- Тут обробляються методи за O(log n)
- Не є синхронізованою
- У двоїчного дерева може бути тільки один або два потомка (може бути відсутній баланс)
- Червоно-чорне дерево вміщує баланс

-----------------------------------------------------------------------------------------------------
    Існують правила, які завжди повинні бути дотримані під час будівництва червоно-чорного дерева:
•	Корінь має бути пофарбований у чорний колір.
•	Листя дерева має бути чорного кольору.
•	Червоний вузол повинен мати два чорні дочірні вузли.
•	Чорний вузол може мати будь-які дочірні вузли.
•	Шлях від вузла до його листя має містити однакову кількість чорних вузлів.
•	Нові вузли додаються на місця листя.
-----------------------------------------------------------------------------------------------------

*Порядок зберігання даних: У порядку зростання або виходячи із заданого компаратора
*час доступу до елементів: O(log(n))
*Імплементовані інтерфейси: NavigableMap, SortedMap, Map
*Імплементація на основі структури даних: Червоно-чорне дерево (Red-Black Tree)
*Можливість роботи з null-ключем: Можна, якщо використовується компаратор, що дозволяє null
*Потокобезпечна:ні


            Set

HashSet

- в основі лежить Map, де зберігається в ключі значення елементу HashSet, а значення в HashSet не використовується,
тому підставляється якась константа заглушка

- не сортується
- коли виконується добавлення, тоді викликається put, якій належить HashMap
- коли добавляється однаковий елемент за значення, джава це бачить і не добавляє елемент
- можемо добавить значеня null
- перевизначаємо завжди equals і hashcode

- union це об'єднання колекції в set ->addAll
- intersect це перетин -> retainAll
- subtract це видалення елементів по колекціях


    TreeSet
- в основі лежить treeMap, сортують в порядку зростання або від комператора
- не можна помістити null, element - key map


            Queue
Queue - колекція, що зберігає послідовність елементів, добавляє елементи в кінець черги, використовуючи з початку черги
rule FIFO

LinkedList імплементує не тільки List, а й Deque
-add->offer
-remove->poll
-element->peek + верхній елемент черги

ПРАЦЮЄМО з елементами, що додається на початок черги і кінець, а не елементами, що по середині знаходяться

        PriorityQueue
працює не так як queue
якщо добавляємо елементи, то є два види сортування: природній або вручний(імплементація Comparable або в параметрі реалізувати Comparator)

пріорітетність має елемент, які є найменшим, після сортування



        vector
застарілий синхронізований клас
в основі масив типу Object
не рекомендується
краще використовувати arraylist

        Stack
застарілий синхронізований клас, якій використовує LIFO
не рекомендується

------------------------------------------------------------------------------------------------------------------------
        Equals and HashCode

1. перевизначати те і те, якщо equals, то і hashcode
2. декілька викликів hashcode для одного й того самого об'єкта має бути один той самий результат
3. якщо equals=true, то hashcode будуть рівні
4. якщо equals=false, то hashcode не обов'язково повинні бути false
5. однаковий hashcode, але різні об'єкти - колізія